# Testing Rules

## General Testing Principles

- Write tests that describe behavior, not implementation
- Use descriptive test names that explain the scenario being tested
- Follow the Arrange-Act-Assert (AAA) pattern
- Keep tests simple and focused on a single behavior
- Make tests independent - they should not depend on other tests

## Test Organization

```
tests/
├── unit/                    # Fast, isolated tests
│   ├── test_user_service.py
│   ├── test_validation.py
│   └── test_utils.py
├── integration/             # Tests with external dependencies
│   ├── test_database.py
│   ├── test_api_endpoints.py
│   └── test_email_service.py
├── e2e/                    # End-to-end tests
│   ├── test_user_workflows.py
│   └── test_purchase_flow.py
├── fixtures/               # Test data
│   ├── sample_users.json
│   └── mock_responses.json
└── conftest.py            # Shared test configuration
```

## Test Naming Conventions

Use descriptive names that explain what is being tested:

```python
# Good test names - explain the scenario and expected outcome
def test_create_user_with_valid_data_returns_user_id():
    pass

def test_create_user_with_duplicate_email_raises_validation_error():
    pass

def test_get_user_when_user_not_found_raises_not_found_error():
    pass

# Bad test names - too generic or implementation-focused
def test_create_user():  # Too generic
    pass

def test_database_insert():  # Implementation detail
    pass
```

## Unit Testing Patterns

### Python with pytest

```python
import pytest
from unittest.mock import Mock, patch
from myapp.services.user_service import UserService
from myapp.exceptions import ValidationError, UserNotFoundError

class TestUserService:
    """Test cases for UserService class."""
    
    @pytest.fixture
    def mock_database(self):
        """Mock database for testing."""
        return Mock()
    
    @pytest.fixture
    def user_service(self, mock_database):
        """Create UserService with mocked dependencies."""
        return UserService(database=mock_database, logger=Mock())
    
    @pytest.fixture
    def valid_user_data(self):
        """Valid user data for testing."""
        return {
            "name": "John Doe",
            "email": "john@example.com",
            "age": 30
        }
    
    def test_create_user_with_valid_data_saves_to_database(
        self, 
        user_service, 
        mock_database, 
        valid_user_data
    ):
        """Test that valid user data is saved to database."""
        # Arrange
        expected_user_id = "user-123"
        mock_database.save_user.return_value = expected_user_id
        
        # Act
        result = user_service.create_user(valid_user_data)
        
        # Assert
        assert result == expected_user_id
        mock_database.save_user.assert_called_once_with(valid_user_data)
    
    def test_create_user_with_invalid_email_raises_validation_error(self, user_service):
        """Test that invalid email format raises ValidationError."""
        # Arrange
        invalid_data = {"name": "John", "email": "invalid-email", "age": 30}
        
        # Act & Assert
        with pytest.raises(ValidationError) as exc_info:
            user_service.create_user(invalid_data)
        
        assert "Invalid email format" in str(exc_info.value)
    
    @patch('myapp.services.user_service.send_welcome_email')
    def test_create_user_sends_welcome_email(
        self, 
        mock_send_email, 
        user_service, 
        mock_database, 
        valid_user_data
    ):
        """Test that welcome email is sent after user creation."""
        # Arrange
        mock_database.save_user.return_value = "user-123"
        
        # Act
        user_service.create_user(valid_user_data)
        
        # Assert
        mock_send_email.assert_called_once_with(valid_user_data['email'])
    
    def test_get_user_when_user_exists_returns_user_data(
        self, 
        user_service, 
        mock_database
    ):
        """Test that existing user data is returned correctly."""
        # Arrange
        user_id = "user-123"
        expected_user = {"id": user_id, "name": "John Doe", "email": "john@example.com"}
        mock_database.get_user_by_id.return_value = expected_user
        
        # Act
        result = user_service.get_user(user_id)
        
        # Assert
        assert result == expected_user
        mock_database.get_user_by_id.assert_called_once_with(user_id)
    
    def test_get_user_when_user_not_found_raises_not_found_error(
        self, 
        user_service, 
        mock_database
    ):
        """Test that UserNotFoundError is raised when user doesn't exist."""
        # Arrange
        user_id = "nonexistent-user"
        mock_database.get_user_by_id.return_value = None
        
        # Act & Assert
        with pytest.raises(UserNotFoundError) as exc_info:
            user_service.get_user(user_id)
        
        assert user_id in str(exc_info.value)
```

### JavaScript/TypeScript with Jest

```typescript
import { UserService } from '../src/services/UserService';
import { ValidationError, UserNotFoundError } from '../src/exceptions';

// Mock external dependencies
jest.mock('../src/database/UserRepository');
jest.mock('../src/services/EmailService');

import { UserRepository } from '../src/database/UserRepository';
import { EmailService } from '../src/services/EmailService';

const mockUserRepository = UserRepository as jest.Mocked<typeof UserRepository>;
const mockEmailService = EmailService as jest.Mocked<typeof EmailService>;

describe('UserService', () => {
  let userService: UserService;
  
  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
    
    // Create service instance with mocked dependencies
    userService = new UserService(
      new mockUserRepository(),
      new mockEmailService()
    );
  });
  
  describe('createUser', () => {
    const validUserData = {
      name: 'John Doe',
      email: 'john@example.com',
      age: 30
    };
    
    it('should save user to database when data is valid', async () => {
      // Arrange
      const expectedUserId = 'user-123';
      mockUserRepository.prototype.save.mockResolvedValue(expectedUserId);
      
      // Act
      const result = await userService.createUser(validUserData);
      
      // Assert
      expect(result).toBe(expectedUserId);
      expect(mockUserRepository.prototype.save).toHaveBeenCalledWith(validUserData);
    });
    
    it('should throw ValidationError when email format is invalid', async () => {
      // Arrange
      const invalidData = { ...validUserData, email: 'invalid-email' };
      
      // Act & Assert
      await expect(userService.createUser(invalidData)).rejects.toThrow(ValidationError);
      expect(mockUserRepository.prototype.save).not.toHaveBeenCalled();
    });
    
    it('should send welcome email after user creation', async () => {
      // Arrange
      mockUserRepository.prototype.save.mockResolvedValue('user-123');
      
      // Act
      await userService.createUser(validUserData);
      
      // Assert
      expect(mockEmailService.prototype.sendWelcomeEmail).toHaveBeenCalledWith(
        validUserData.email
      );
    });
  });
  
  describe('getUser', () => {
    it('should return user data when user exists', async () => {
      // Arrange
      const userId = 'user-123';
      const expectedUser = { id: userId, name: 'John Doe', email: 'john@example.com' };
      mockUserRepository.prototype.findById.mockResolvedValue(expectedUser);
      
      // Act
      const result = await userService.getUser(userId);
      
      // Assert
      expect(result).toEqual(expectedUser);
      expect(mockUserRepository.prototype.findById).toHaveBeenCalledWith(userId);
    });
    
    it('should throw UserNotFoundError when user does not exist', async () => {
      // Arrange
      const userId = 'nonexistent-user';
      mockUserRepository.prototype.findById.mockResolvedValue(null);
      
      // Act & Assert
      await expect(userService.getUser(userId)).rejects.toThrow(UserNotFoundError);
    });
  });
});
```

## Integration Testing

Test components working together with real dependencies:

```python
import pytest
from myapp.app import create_app
from myapp.database import get_database_connection

@pytest.fixture(scope='session')
def test_database():
    """Create test database for integration tests."""
    db = get_database_connection('test_database')
    db.create_all_tables()
    yield db
    db.drop_all_tables()
    db.close()

@pytest.fixture
def app(test_database):
    """Create Flask app for testing."""
    app = create_app(database=test_database)
    app.config['TESTING'] = True
    return app

@pytest.fixture
def client(app):
    """Create test client."""
    return app.test_client()

def test_create_user_endpoint_creates_user_in_database(client, test_database):
    """Test that POST /users creates user in database."""
    # Arrange
    user_data = {
        "name": "John Doe",
        "email": "john@example.com",
        "age": 30
    }
    
    # Act
    response = client.post('/users', json=user_data)
    
    # Assert
    assert response.status_code == 201
    
    # Verify user was created in database
    created_user = test_database.get_user_by_email("john@example.com")
    assert created_user is not None
    assert created_user['name'] == "John Doe"
```

## React Component Testing

```typescript
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserProfile } from '../components/UserProfile';

// Mock API calls
jest.mock('../services/api');
import { fetchUser, updateUser } from '../services/api';
const mockFetchUser = fetchUser as jest.MockedFunction<typeof fetchUser>;
const mockUpdateUser = updateUser as jest.MockedFunction<typeof updateUser>;

describe('UserProfile Component', () => {
  const mockUser = {
    id: '123',
    name: 'John Doe',
    email: 'john@example.com',
    age: 30
  };
  
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('should display user information when loaded', async () => {
    // Arrange
    mockFetchUser.mockResolvedValue(mockUser);
    
    // Act
    render(<UserProfile userId="123" />);
    
    // Assert
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('john@example.com')).toBeInTheDocument();
    });
  });
  
  it('should show loading state while fetching user', () => {
    // Arrange
    mockFetchUser.mockImplementation(() => new Promise(() => {})); // Never resolves
    
    // Act
    render(<UserProfile userId="123" />);
    
    // Assert
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });
  
  it('should allow editing user name', async () => {
    // Arrange
    const user = userEvent.setup();
    mockFetchUser.mockResolvedValue(mockUser);
    mockUpdateUser.mockResolvedValue({ ...mockUser, name: 'Jane Doe' });
    
    render(<UserProfile userId="123" />);
    
    // Wait for component to load
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
    });
    
    // Act
    const editButton = screen.getByRole('button', { name: 'Edit' });
    await user.click(editButton);
    
    const nameInput = screen.getByRole('textbox', { name: 'Name' });
    await user.clear(nameInput);
    await user.type(nameInput, 'Jane Doe');
    
    const saveButton = screen.getByRole('button', { name: 'Save' });
    await user.click(saveButton);
    
    // Assert
    await waitFor(() => {
      expect(mockUpdateUser).toHaveBeenCalledWith('123', { 
        name: 'Jane Doe',
        email: 'john@example.com',
        age: 30
      });
    });
  });
});
```

## Test Data Management

Create reusable test data and fixtures:

```python
# conftest.py
import pytest
from datetime import datetime

@pytest.fixture
def sample_user():
    """Sample user data for testing."""
    return {
        "id": "user-123",
        "name": "John Doe",
        "email": "john@example.com",
        "age": 30,
        "created_at": datetime(2023, 1, 1, 12, 0, 0)
    }

@pytest.fixture
def sample_users():
    """Multiple sample users for testing."""
    return [
        {
            "id": "user-1",
            "name": "Alice Smith",
            "email": "alice@example.com",
            "age": 25
        },
        {
            "id": "user-2",
            "name": "Bob Johnson",
            "email": "bob@example.com",
            "age": 35
        }
    ]

# Factory pattern for test data
class UserFactory:
    @staticmethod
    def create_user(name="John Doe", email="john@example.com", **kwargs):
        """Create user data with customizable fields."""
        default_user = {
            "id": "user-123",
            "name": name,
            "email": email,
            "age": 30,
            "created_at": datetime.now()
        }
        default_user.update(kwargs)
        return default_user
    
    @staticmethod
    def create_admin_user(**kwargs):
        """Create admin user data."""
        return UserFactory.create_user(
            name="Admin User",
            email="admin@example.com",
            role="admin",
            **kwargs
        )
```

## Performance Testing

```python
import pytest
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

def test_user_service_performance_under_load():
    """Test that user service maintains performance under concurrent load."""
    
    def create_user_task(user_index):
        """Create a single user - task for thread pool."""
        user_data = {
            "name": f"User {user_index}",
            "email": f"user{user_index}@example.com",
            "age": 25
        }
        start_time = time.time()
        result = user_service.create_user(user_data)
        end_time = time.time()
        return result, end_time - start_time
    
    # Test with 50 concurrent user creations
    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(create_user_task, i) for i in range(50)]
        
        results = []
        response_times = []
        
        for future in as_completed(futures):
            user_id, response_time = future.result()
            results.append(user_id)
            response_times.append(response_time)
    
    # Assert all users were created
    assert len(results) == 50
    assert all(user_id is not None for user_id in results)
    
    # Assert performance requirements
    average_response_time = sum(response_times) / len(response_times)
    max_response_time = max(response_times)
    
    assert average_response_time < 0.1  # Average under 100ms
    assert max_response_time < 0.5      # Max under 500ms
```

## Test Coverage and Quality

- Aim for 80%+ code coverage, 100% for critical paths
- Use coverage tools to identify untested code
- Write tests for edge cases and error conditions
- Keep tests maintainable - refactor test code too
- Use descriptive assertions that explain what went wrong

```python
# Good assertions - explain what's expected
assert len(users) == 3, f"Expected 3 users, got {len(users)}"
assert user.email == "john@example.com", f"Expected john@example.com, got {user.email}"

# Use pytest's assert with helpful failure messages
def test_user_validation():
    user_data = {"name": "", "email": "invalid"}
    
    with pytest.raises(ValidationError) as exc_info:
        validate_user(user_data)
    
    # Check specific error details
    error_message = str(exc_info.value)
    assert "Name is required" in error_message
    assert "Invalid email format" in error_message
```

Follow these testing patterns to create reliable, maintainable test suites that give you confidence in your code changes.