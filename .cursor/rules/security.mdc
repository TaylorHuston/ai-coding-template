# Security Rules

## Core Security Principles

- **Defense in Depth**: Implement security at multiple layers
- **Principle of Least Privilege**: Grant minimum necessary permissions
- **Fail Securely**: Systems should fail to a secure state
- **Don't Trust User Input**: Validate and sanitize all inputs
- **Security by Default**: Make the secure choice the easy choice

## Input Validation and Sanitization

### Validate All Inputs

```python
from typing import Dict, Any
import re
from html import escape

def validate_user_input(user_data: Dict[str, Any]) -> Dict[str, Any]:
    """Validate and sanitize user input."""
    
    # Email validation
    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_pattern, user_data.get('email', '')):
        raise ValidationError("Invalid email format")
    
    # Name validation - remove potentially dangerous characters
    name = user_data.get('name', '').strip()
    if not name or len(name) < 2 or len(name) > 100:
        raise ValidationError("Name must be between 2 and 100 characters")
    
    # Sanitize HTML content
    bio = escape(user_data.get('bio', ''))
    
    return {
        'email': user_data['email'].lower().strip(),
        'name': name,
        'bio': bio
    }
```

### SQL Injection Prevention

```python
# Use parameterized queries - NEVER string concatenation
def get_user_by_email(email: str) -> Optional[Dict]:
    """Get user by email using parameterized query."""
    query = "SELECT * FROM users WHERE email = %s"
    cursor.execute(query, (email,))
    return cursor.fetchone()

# For dynamic queries, use query builders or ORMs
from sqlalchemy import text

def search_users(filters: Dict[str, Any]) -> List[Dict]:
    """Search users with dynamic filters."""
    base_query = "SELECT * FROM users WHERE 1=1"
    params = {}
    
    if 'name' in filters:
        base_query += " AND name ILIKE :name"
        params['name'] = f"%{filters['name']}%"
    
    if 'age_min' in filters:
        base_query += " AND age >= :age_min"
        params['age_min'] = int(filters['age_min'])
    
    result = db.execute(text(base_query), params)
    return result.fetchall()
```

### XSS Prevention

```typescript
// React - Use JSX's built-in escaping
function UserProfile({ user }: { user: User }) {
  return (
    <div>
      {/* Safe - JSX automatically escapes */}
      <h1>{user.name}</h1>
      <p>{user.bio}</p>
      
      {/* Dangerous - avoid dangerouslySetInnerHTML unless necessary */}
      {/* <div dangerouslySetInnerHTML={{ __html: user.bio }} /> */}
    </div>
  );
}

// When you must render HTML, sanitize it first
import DOMPurify from 'dompurify';

function renderSafeHTML(htmlContent: string): string {
  return DOMPurify.sanitize(htmlContent, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: []
  });
}
```

## Authentication and Authorization

### Secure Password Handling

```python
import bcrypt
import secrets
from datetime import datetime, timedelta

class PasswordManager:
    """Secure password handling."""
    
    @staticmethod
    def hash_password(password: str) -> str:
        """Hash password using bcrypt."""
        # Generate salt and hash password
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
        return hashed.decode('utf-8')
    
    @staticmethod
    def verify_password(password: str, hashed_password: str) -> bool:
        """Verify password against hash."""
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed_password.encode('utf-8')
        )
    
    @staticmethod
    def generate_secure_token() -> str:
        """Generate cryptographically secure random token."""
        return secrets.token_urlsafe(32)

def validate_password_strength(password: str) -> None:
    """Validate password meets security requirements."""
    if len(password) < 8:
        raise ValidationError("Password must be at least 8 characters")
    
    if not re.search(r'[A-Z]', password):
        raise ValidationError("Password must contain uppercase letter")
    
    if not re.search(r'[a-z]', password):
        raise ValidationError("Password must contain lowercase letter")
    
    if not re.search(r'\d', password):
        raise ValidationError("Password must contain a number")
    
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        raise ValidationError("Password must contain special character")
```

### JWT Token Security

```python
import jwt
from datetime import datetime, timedelta
from typing import Dict, Any

class TokenManager:
    """Secure JWT token management."""
    
    def __init__(self, secret_key: str):
        self.secret_key = secret_key
        self.algorithm = 'HS256'
    
    def generate_access_token(self, user_id: str) -> str:
        """Generate short-lived access token."""
        payload = {
            'user_id': user_id,
            'type': 'access',
            'exp': datetime.utcnow() + timedelta(minutes=15),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def generate_refresh_token(self, user_id: str) -> str:
        """Generate long-lived refresh token."""
        payload = {
            'user_id': user_id,
            'type': 'refresh',
            'exp': datetime.utcnow() + timedelta(days=30),
            'iat': datetime.utcnow()
        }
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str, token_type: str = 'access') -> Dict[str, Any]:
        """Verify and decode token."""
        try:
            payload = jwt.decode(
                token, 
                self.secret_key, 
                algorithms=[self.algorithm]
            )
            
            if payload.get('type') != token_type:
                raise InvalidTokenError(f"Invalid token type: expected {token_type}")
            
            return payload
            
        except jwt.ExpiredSignatureError:
            raise ExpiredTokenError("Token has expired")
        except jwt.InvalidTokenError:
            raise InvalidTokenError("Invalid token")
```

### Role-Based Access Control

```python
from enum import Enum
from functools import wraps

class Role(Enum):
    USER = "user"
    ADMIN = "admin"
    MODERATOR = "moderator"

class Permission(Enum):
    READ_USERS = "read_users"
    WRITE_USERS = "write_users"
    DELETE_USERS = "delete_users"
    READ_ADMIN = "read_admin"

# Role-permission mapping
ROLE_PERMISSIONS = {
    Role.USER: [Permission.READ_USERS],
    Role.MODERATOR: [Permission.READ_USERS, Permission.WRITE_USERS],
    Role.ADMIN: [Permission.READ_USERS, Permission.WRITE_USERS, 
                Permission.DELETE_USERS, Permission.READ_ADMIN]
}

def require_permission(permission: Permission):
    """Decorator to require specific permission."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Get current user from context (varies by framework)
            current_user = get_current_user()
            
            if not current_user:
                raise AuthenticationError("Authentication required")
            
            user_permissions = ROLE_PERMISSIONS.get(current_user.role, [])
            if permission not in user_permissions:
                raise AuthorizationError(
                    f"Permission denied: {permission.value} required"
                )
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Usage
@require_permission(Permission.DELETE_USERS)
def delete_user(user_id: str) -> None:
    """Delete user - requires admin role."""
    # Implementation here
    pass
```

## Secure Configuration Management

### Environment Variable Validation

```python
import os
from dataclasses import dataclass
from typing import Optional

@dataclass
class SecurityConfig:
    """Security configuration with validation."""
    secret_key: str
    jwt_secret: str
    database_password: str
    encryption_key: str
    
    def __post_init__(self):
        """Validate security configuration."""
        # Ensure secrets are not default/weak values
        weak_secrets = ['secret', 'password', 'dev', 'test', '123456']
        
        if any(weak in self.secret_key.lower() for weak in weak_secrets):
            raise ConfigurationError("Weak secret key detected")
        
        if len(self.secret_key) < 32:
            raise ConfigurationError("Secret key must be at least 32 characters")
        
        if len(self.jwt_secret) < 32:
            raise ConfigurationError("JWT secret must be at least 32 characters")

def load_security_config() -> SecurityConfig:
    """Load security configuration with validation."""
    secret_key = os.getenv('SECRET_KEY')
    if not secret_key:
        raise ConfigurationError("SECRET_KEY environment variable required")
    
    jwt_secret = os.getenv('JWT_SECRET')
    if not jwt_secret:
        raise ConfigurationError("JWT_SECRET environment variable required")
    
    return SecurityConfig(
        secret_key=secret_key,
        jwt_secret=jwt_secret,
        database_password=os.getenv('DB_PASSWORD', ''),
        encryption_key=os.getenv('ENCRYPTION_KEY', '')
    )
```

### Secrets Management

```python
# Never store secrets in code
# BAD
# SECRET_KEY = "my-secret-key-123"
# DATABASE_URL = "postgresql://user:password@localhost/db"

# GOOD - Use environment variables
import os

SECRET_KEY = os.getenv('SECRET_KEY')
DATABASE_URL = os.getenv('DATABASE_URL')

# Better - Use dedicated secrets management
# AWS Secrets Manager, Azure Key Vault, HashiCorp Vault, etc.

import boto3

def get_database_credentials() -> Dict[str, str]:
    """Get database credentials from AWS Secrets Manager."""
    client = boto3.client('secretsmanager')
    
    try:
        response = client.get_secret_value(SecretId='prod/database/credentials')
        secret = json.loads(response['SecretString'])
        return {
            'host': secret['host'],
            'username': secret['username'],
            'password': secret['password']
        }
    except Exception as e:
        logger.error(f"Failed to retrieve database credentials: {e}")
        raise
```

## Data Protection

### Encryption at Rest

```python
from cryptography.fernet import Fernet
import base64

class DataEncryption:
    """Encrypt sensitive data at rest."""
    
    def __init__(self, encryption_key: str):
        # Key should be from environment variable
        self.cipher = Fernet(encryption_key.encode())
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """Encrypt sensitive string data."""
        encrypted_data = self.cipher.encrypt(data.encode())
        return base64.b64encode(encrypted_data).decode()
    
    def decrypt_sensitive_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive string data."""
        decoded_data = base64.b64decode(encrypted_data.encode())
        decrypted_data = self.cipher.decrypt(decoded_data)
        return decrypted_data.decode()

# Usage for PII or sensitive data
encryptor = DataEncryption(os.getenv('ENCRYPTION_KEY'))

def store_user_ssn(user_id: str, ssn: str) -> None:
    """Store encrypted SSN."""
    encrypted_ssn = encryptor.encrypt_sensitive_data(ssn)
    database.save_encrypted_field(user_id, 'ssn', encrypted_ssn)
```

### Data Masking for Logs

```python
import re
from typing import Dict, Any

def mask_sensitive_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """Mask sensitive data in logs."""
    
    sensitive_patterns = {
        'email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
        'ssn': r'\d{3}-\d{2}-\d{4}',
        'phone': r'\(\d{3}\)\s?\d{3}-\d{4}',
        'credit_card': r'\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}'
    }
    
    def mask_string(text: str) -> str:
        """Mask sensitive patterns in string."""
        for pattern_name, pattern in sensitive_patterns.items():
            # Replace with masked version
            if pattern_name == 'email':
                text = re.sub(pattern, 'user@*****.com', text)
            elif pattern_name == 'ssn':
                text = re.sub(pattern, '***-**-****', text)
            else:
                text = re.sub(pattern, '*' * 10, text)
        return text
    
    # Recursively mask data
    masked_data = {}
    for key, value in data.items():
        if isinstance(value, str):
            masked_data[key] = mask_string(value)
        elif isinstance(value, dict):
            masked_data[key] = mask_sensitive_data(value)
        elif isinstance(value, list):
            masked_data[key] = [
                mask_sensitive_data(item) if isinstance(item, dict)
                else mask_string(str(item)) if isinstance(item, str)
                else item
                for item in value
            ]
        else:
            masked_data[key] = value
    
    return masked_data

# Usage in logging
logger.info("User created", extra=mask_sensitive_data({
    "user_id": "123",
    "email": "user@example.com",
    "ssn": "123-45-6789"
}))
```

## Secure HTTP Headers

```python
# Flask example
from flask import Flask

def add_security_headers(app: Flask) -> None:
    """Add security headers to Flask app."""
    
    @app.after_request
    def security_headers(response):
        # Prevent XSS attacks
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        
        # HTTPS enforcement
        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
        
        # Content Security Policy
        response.headers['Content-Security-Policy'] = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:; "
            "font-src 'self' https:"
        )
        
        # Remove server information
        response.headers.pop('Server', None)
        
        return response
```

## API Security

### Rate Limiting

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["1000 per hour"]
)

@app.route('/api/login', methods=['POST'])
@limiter.limit("5 per minute")  # Prevent brute force
def login():
    """Login endpoint with rate limiting."""
    pass

@app.route('/api/users', methods=['POST'])
@limiter.limit("10 per minute")  # Prevent spam
def create_user():
    """Create user endpoint with rate limiting."""
    pass
```

### API Key Security

```python
import hmac
import hashlib
from datetime import datetime

def generate_api_signature(
    api_key: str, 
    method: str, 
    path: str, 
    body: str, 
    timestamp: str
) -> str:
    """Generate API request signature."""
    message = f"{method}\n{path}\n{body}\n{timestamp}"
    signature = hmac.new(
        api_key.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    return signature

def verify_api_request(request) -> bool:
    """Verify API request signature."""
    api_key = get_api_key_from_database(request.headers.get('X-API-Key'))
    if not api_key:
        return False
    
    timestamp = request.headers.get('X-Timestamp')
    signature = request.headers.get('X-Signature')
    
    # Check timestamp is recent (prevent replay attacks)
    request_time = datetime.fromisoformat(timestamp)
    if (datetime.utcnow() - request_time).total_seconds() > 300:  # 5 minutes
        return False
    
    expected_signature = generate_api_signature(
        api_key,
        request.method,
        request.path,
        request.get_data(as_text=True),
        timestamp
    )
    
    return hmac.compare_digest(signature, expected_signature)
```

## Security Testing

```python
import pytest
from unittest.mock import patch

class TestSecurityFeatures:
    """Test security features."""
    
    def test_sql_injection_prevention(self, client):
        """Test that SQL injection attempts are blocked."""
        malicious_input = "'; DROP TABLE users; --"
        
        response = client.post('/api/users/search', json={
            'name': malicious_input
        })
        
        # Should not cause internal server error
        assert response.status_code in [400, 422]  # Bad request or validation error
        
        # Verify users table still exists
        users = client.get('/api/users').json
        assert isinstance(users, list)  # Table not dropped
    
    def test_xss_prevention(self, client):
        """Test that XSS attempts are sanitized."""
        malicious_script = '<script>alert("xss")</script>'
        
        response = client.post('/api/users', json={
            'name': 'Test User',
            'bio': malicious_script
        })
        
        assert response.status_code == 201
        
        # Verify script tag was sanitized
        user = response.json
        assert '<script>' not in user['bio']
        assert 'alert(' not in user['bio']
    
    def test_password_hashing(self):
        """Test that passwords are properly hashed."""
        password = "secure_password123"
        hashed = PasswordManager.hash_password(password)
        
        # Password should not be stored in plain text
        assert password not in hashed
        assert len(hashed) > 50  # Bcrypt produces long hashes
        
        # Should verify correctly
        assert PasswordManager.verify_password(password, hashed)
        assert not PasswordManager.verify_password("wrong_password", hashed)
    
    def test_rate_limiting(self, client):
        """Test rate limiting prevents abuse."""
        # Make requests up to the limit
        for i in range(5):  # Assuming 5 per minute limit
            response = client.post('/api/login', json={
                'email': 'test@example.com',
                'password': 'wrong_password'
            })
            assert response.status_code in [400, 401]  # Auth failure, not rate limit
        
        # Next request should be rate limited
        response = client.post('/api/login', json={
            'email': 'test@example.com',
            'password': 'wrong_password'
        })
        assert response.status_code == 429  # Too Many Requests
```

## Security Checklist

### Input Handling
- [ ] All user inputs validated and sanitized
- [ ] SQL injection prevention (parameterized queries)
- [ ] XSS prevention (output encoding)
- [ ] File upload restrictions (type, size, location)
- [ ] Path traversal prevention

### Authentication & Authorization
- [ ] Strong password requirements
- [ ] Secure password hashing (bcrypt/scrypt/Argon2)
- [ ] Multi-factor authentication for sensitive operations
- [ ] Role-based access control implemented
- [ ] Session management secure (timeouts, secure cookies)

### Data Protection
- [ ] Sensitive data encrypted at rest
- [ ] Data encrypted in transit (HTTPS)
- [ ] PII/sensitive data not logged
- [ ] Secure backup and recovery procedures
- [ ] Data retention policies implemented

### Configuration Security
- [ ] No secrets in code or version control
- [ ] Environment variables for configuration
- [ ] Security headers configured
- [ ] Error messages don't expose sensitive information
- [ ] Logging configured securely

### API Security
- [ ] Rate limiting implemented
- [ ] API authentication/authorization
- [ ] Request/response validation
- [ ] CORS properly configured
- [ ] API versioning strategy

### Infrastructure Security
- [ ] Regular security updates applied
- [ ] Network segmentation implemented
- [ ] Monitoring and alerting configured
- [ ] Incident response plan documented
- [ ] Regular security assessments performed

Remember: Security is an ongoing process, not a one-time implementation. Regularly review and update your security measures as threats evolve.