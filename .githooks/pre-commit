#!/bin/bash

# AI Coding Template Pre-Commit Hook - Context-Aware & User-Friendly
# Version: 0.2.0
# Description: Intelligent pre-commit validation with context awareness

set -euo pipefail

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CONFIG_FILE=".githooks.json"
CI_MODE=${CI:-false}
FORCE_COMMIT=${FORCE_COMMIT:-false}

# Progress tracking
CHECKS_TOTAL=0
CHECKS_PASSED=0
CHECKS_WARNED=0
CHECKS_FAILED=0

# Load configuration with fallback
load_config() {
    if [[ -f "$CONFIG_FILE" ]] && command -v jq >/dev/null 2>&1; then
        CONFIG=$(cat "$CONFIG_FILE")
    else
        echo -e "${YELLOW}Warning: .githooks.json not found or jq not available, using minimal defaults${NC}"
        CONFIG='{"pre-commit":{"enabled":true,"checks":{},"error-handling":{"continue-on-warning":true}}}'
    fi
}

# Get config value with fallback
get_config() {
    local path="$1"
    local default="$2"
    if command -v jq >/dev/null 2>&1; then
        echo "$CONFIG" | jq -r "$path // \"$default\""
    else
        echo "$default"
    fi
}

# Check if feature is enabled
is_enabled() {
    local check="$1"
    local enabled=$(get_config ".\"pre-commit\".checks.\"$check\".enabled" "false")
    [[ "$enabled" == "true" ]]
}

# Progress indicator
show_progress() {
    local current="$1"
    local total="$2"
    local check_name="$3"

    if [[ "$CI_MODE" != "true" ]]; then
        local percent=$((current * 100 / total))
        printf "\r${BLUE}[%d/%d]${NC} %s... " "$current" "$total" "$check_name"
    else
        echo "Running check: $check_name"
    fi
}

# Log results
log_result() {
    local level="$1"
    local message="$2"

    case "$level" in
        "pass")
            CHECKS_PASSED=$((CHECKS_PASSED + 1))
            if [[ "$CI_MODE" != "true" ]]; then
                echo -e "${GREEN}âœ“${NC} $message"
            else
                echo "PASS: $message"
            fi
            ;;
        "warn")
            CHECKS_WARNED=$((CHECKS_WARNED + 1))
            if [[ "$CI_MODE" != "true" ]]; then
                echo -e "${YELLOW}âš ${NC} $message"
            else
                echo "WARN: $message"
            fi
            ;;
        "fail")
            CHECKS_FAILED=$((CHECKS_FAILED + 1))
            if [[ "$CI_MODE" != "true" ]]; then
                echo -e "${RED}âœ—${NC} $message"
            else
                echo "FAIL: $message"
            fi
            ;;
    esac
}

# Get staged files with context awareness
get_staged_files() {
    git diff --cached --name-only --diff-filter=ACMR
}

# Check if file should be excluded based on patterns
is_excluded_file() {
    local file="$1"
    local exclude_patterns="$2"

    if [[ -z "$exclude_patterns" || "$exclude_patterns" == "null" ]]; then
        return 1
    fi

    echo "$exclude_patterns" | jq -r '.[]?' 2>/dev/null | while read -r pattern; do
        if [[ "$file" =~ $pattern ]]; then
            return 0
        fi
    done

    return 1
}

# Branch protection check
check_branch_protection() {
    if ! is_enabled "branch-protection"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "branch protection"

    local current_branch=$(git branch --show-current)
    local protected_branches=$(get_config '.["pre-commit"].checks["branch-protection"]["protected-branches"]' '[]')

    if echo "$protected_branches" | jq -r '.[]?' | grep -q "^$current_branch$"; then
        local allow_bypass=$(get_config '.["pre-commit"].checks["branch-protection"]["allow-emergency-bypass"]' "false")
        if [[ "$allow_bypass" == "true" && "$FORCE_COMMIT" == "true" ]]; then
            log_result "warn" "Branch protection bypassed for emergency commit"
            return 0
        fi
        log_result "fail" "Direct commits to protected branch '$current_branch' are not allowed"
        return 1
    fi

    log_result "pass" "Branch protection check passed"
    return 0
}

# Security scan with context awareness
check_security() {
    if ! is_enabled "security-scan"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "security scan"

    local staged_files
    staged_files=$(get_staged_files)

    if [[ -z "$staged_files" ]]; then
        log_result "pass" "No staged files to scan"
        return 0
    fi

    local exclude_paths=$(get_config '.["pre-commit"].checks["security-scan"]["exclude-paths"]' '[]')
    local patterns=$(get_config '.["pre-commit"].checks["security-scan"].patterns' '{}')
    local violations=0

    while IFS= read -r file; do
        # Skip if file is excluded
        if is_excluded_file "$file" "$exclude_paths"; then
            continue
        fi

        # Skip if file doesn't exist (deleted)
        if [[ ! -f "$file" ]]; then
            continue
        fi

        # Check each security pattern
        if command -v jq >/dev/null 2>&1; then
            echo "$patterns" | jq -r 'keys[]' | while read -r pattern_name; do
                local regex=$(echo "$patterns" | jq -r ".\"$pattern_name\".regex")
                local severity=$(echo "$patterns" | jq -r ".\"$pattern_name\".severity // \"medium\"")
                local exclude_if_contains=$(echo "$patterns" | jq -r ".\"$pattern_name\".\"exclude-if-contains\" // []")

                if grep -i "$regex" "$file" >/dev/null 2>&1; then
                    # Check if content should be excluded
                    local should_exclude=false
                    if [[ "$exclude_if_contains" != "null" ]]; then
                        echo "$exclude_if_contains" | jq -r '.[]?' | while read -r exclude_term; do
                            if grep -i "$exclude_term" "$file" >/dev/null 2>&1; then
                                should_exclude=true
                                break
                            fi
                        done
                    fi

                    if [[ "$should_exclude" != "true" ]]; then
                        log_result "warn" "Security: Potential $pattern_name found in $file"
                        violations=$((violations + 1))
                    fi
                fi
            done
        fi
    done <<< "$staged_files"

    if [[ "$violations" -eq 0 ]]; then
        log_result "pass" "Security scan passed"
        return 0
    else
        log_result "warn" "Security scan found $violations potential issues"
        return 0  # Warning only by default
    fi
}

# File naming check with deleted file handling
check_file_naming() {
    if ! is_enabled "file-naming"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "file naming"

    local skip_deleted=$(get_config '.["pre-commit"].checks["file-naming"]["skip-deleted-files"]' "true")
    local staged_files

    if [[ "$skip_deleted" == "true" ]]; then
        staged_files=$(git diff --cached --name-only --diff-filter=ACM)
    else
        staged_files=$(get_staged_files)
    fi

    local violations=0
    local rules=$(get_config '.["pre-commit"].checks["file-naming"].rules' '{}')

    while IFS= read -r file; do
        if [[ -z "$file" ]]; then
            continue
        fi

        # Check documentation files
        if [[ "$file" =~ \.md$ ]]; then
            local basename=$(basename "$file" .md)
            local exceptions=$(get_config '.["pre-commit"].checks["file-naming"].rules.documentation.exceptions' '[]')

            # Check if it's an exception
            local is_exception=false
            if echo "$exceptions" | jq -r '.[]?' | grep -q "^$basename$"; then
                is_exception=true
            fi

            # Check if it's a template
            local allow_templates=$(get_config '.["pre-commit"].checks["file-naming"].rules.documentation["allow-templates"]' "true")
            if [[ "$allow_templates" == "true" && "$basename" =~ \.template$ ]]; then
                is_exception=true
            fi

            if [[ "$is_exception" != "true" && ! "$basename" =~ ^[a-z0-9-]+$ ]]; then
                log_result "warn" "Naming: Documentation file '$file' should use lowercase-kebab-case"
                violations=$((violations + 1))
            fi
        fi
    done <<< "$staged_files"

    if [[ "$violations" -eq 0 ]]; then
        log_result "pass" "File naming check passed"
        return 0
    else
        log_result "warn" "File naming found $violations issues"
        return 0  # Warning only by default
    fi
}

# File size check
check_file_size() {
    if ! is_enabled "file-size"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "file size"

    local staged_files
    staged_files=$(get_staged_files)
    local max_size_mb=$(get_config '.["pre-commit"].checks["file-size"]["max-file-size-mb"]' "10")
    local warn_size_mb=$(get_config '.["pre-commit"].checks["file-size"]["large-file-warning-mb"]' "5")
    local exclude_patterns=$(get_config '.["pre-commit"].checks["file-size"]["exclude-patterns"]' '[]')

    local violations=0
    local max_size_bytes=$((max_size_mb * 1024 * 1024))
    local warn_size_bytes=$((warn_size_mb * 1024 * 1024))

    while IFS= read -r file; do
        if [[ -z "$file" || ! -f "$file" ]]; then
            continue
        fi

        # Skip excluded patterns
        if is_excluded_file "$file" "$exclude_patterns"; then
            continue
        fi

        local size
        size=$(stat -c%s "$file" 2>/dev/null || echo "0")

        if [[ "$size" -gt "$max_size_bytes" ]]; then
            log_result "warn" "File size: '$file' exceeds ${max_size_mb}MB limit"
            violations=$((violations + 1))
        elif [[ "$size" -gt "$warn_size_bytes" ]]; then
            log_result "warn" "File size: '$file' is larger than ${warn_size_mb}MB"
        fi
    done <<< "$staged_files"

    if [[ "$violations" -eq 0 ]]; then
        log_result "pass" "File size check passed"
        return 0
    else
        log_result "warn" "File size check found $violations large files"
        return 0  # Warning only by default
    fi
}

# AI documentation check
check_ai_documentation() {
    if ! is_enabled "ai-documentation"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "AI documentation"

    local require_indicator=$(get_config '.["pre-commit"].checks["ai-documentation"]["require-ai-indicator"]' "false")
    local warning_only=$(get_config '.["pre-commit"].checks["ai-documentation"]["warning-only"]' "true")

    # This is a placeholder - actual implementation would check commit messages
    # For now, just pass since it's warning-only by default
    log_result "pass" "AI documentation check passed"
    return 0
}

# Documentation updates check
check_documentation_updates() {
    if ! is_enabled "documentation-updates"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "documentation updates"

    local staged_files
    staged_files=$(get_staged_files)
    local code_patterns=$(get_config '.["pre-commit"].checks["documentation-updates"]["code-file-patterns"]' '[]')
    local has_code_changes=false

    # Check if there are code file changes
    while IFS= read -r file; do
        if [[ -z "$file" ]]; then
            continue
        fi

        echo "$code_patterns" | jq -r '.[]?' | while read -r pattern; do
            if [[ "$file" =~ $pattern ]]; then
                has_code_changes=true
                break
            fi
        done
    done <<< "$staged_files"

    if [[ "$has_code_changes" == "true" ]]; then
        log_result "warn" "Documentation: Consider updating docs for code changes"
    else
        log_result "pass" "Documentation updates check passed"
    fi

    return 0
}

# Changelog reminder
check_changelog_reminder() {
    if ! is_enabled "changelog-reminder"; then
        return 0
    fi

    ((CHECKS_TOTAL++))
    show_progress "$CHECKS_TOTAL" 7 "changelog reminder"

    # Check commit message for feature/fix indicators
    local commit_msg_file=".git/COMMIT_EDITMSG"
    local has_feature_changes=false

    if [[ -f "$commit_msg_file" ]]; then
        local check_for=$(get_config '.["pre-commit"].checks["changelog-reminder"]["check-for"]' '{}')

        if echo "$check_for" | jq -r '.features[]?, .fixes[]?, .breaking[]?' | grep -q -f - "$commit_msg_file"; then
            has_feature_changes=true
        fi
    fi

    if [[ "$has_feature_changes" == "true" ]]; then
        log_result "warn" "Changelog: Consider updating CHANGELOG.md for this change"
    else
        log_result "pass" "Changelog reminder check passed"
    fi

    return 0
}

# Main execution
main() {
    # Load configuration
    load_config

    # Check if pre-commit is enabled
    local enabled=$(get_config '.["pre-commit"].enabled' "true")
    if [[ "$enabled" != "true" ]]; then
        echo "Pre-commit hooks are disabled"
        exit 0
    fi

    # Initialize check counts
    CHECKS_TOTAL=0
    CHECKS_PASSED=0
    CHECKS_WARNED=0
    CHECKS_FAILED=0

    # Show header
    if [[ "$CI_MODE" != "true" ]]; then
        echo -e "${BLUE}ðŸ” Running pre-commit validation...${NC}"
        echo
    else
        echo "Running pre-commit validation..."
    fi

    # Run all checks
    local overall_result=0

    check_branch_protection || overall_result=1
    check_security || overall_result=1
    check_file_naming || overall_result=1
    check_file_size || overall_result=1
    check_ai_documentation || overall_result=1
    check_documentation_updates || overall_result=1
    check_changelog_reminder || overall_result=1

    # Show summary
    echo
    if [[ "$CI_MODE" != "true" ]]; then
        echo -e "${BLUE}ðŸ“Š Summary:${NC}"
        echo -e "  ${GREEN}âœ“ Passed: $CHECKS_PASSED${NC}"
        echo -e "  ${YELLOW}âš  Warnings: $CHECKS_WARNED${NC}"
        echo -e "  ${RED}âœ— Failed: $CHECKS_FAILED${NC}"
    else
        echo "Summary: Passed: $CHECKS_PASSED, Warnings: $CHECKS_WARNED, Failed: $CHECKS_FAILED"
    fi

    # Handle results
    local continue_on_warning=$(get_config '.["pre-commit"]["error-handling"]["continue-on-warning"]' "true")

    if [[ "$CHECKS_FAILED" -gt 0 ]]; then
        echo
        if [[ "$CI_MODE" != "true" ]]; then
            echo -e "${RED}âŒ Commit blocked due to failed checks${NC}"
            echo -e "${YELLOW}ðŸ’¡ To bypass: git commit --no-verify${NC}"
        else
            echo "Commit blocked due to failed checks"
            echo "To bypass: git commit --no-verify"
        fi
        exit 1
    elif [[ "$CHECKS_WARNED" -gt 0 && "$continue_on_warning" != "true" ]]; then
        echo
        if [[ "$CI_MODE" != "true" ]]; then
            echo -e "${YELLOW}âš ï¸ Commit blocked due to warnings${NC}"
            echo -e "${YELLOW}ðŸ’¡ To bypass: git commit --no-verify${NC}"
        else
            echo "Commit blocked due to warnings"
            echo "To bypass: git commit --no-verify"
        fi
        exit 1
    else
        echo
        if [[ "$CI_MODE" != "true" ]]; then
            echo -e "${GREEN}âœ… All checks passed! Proceeding with commit...${NC}"
        else
            echo "All checks passed! Proceeding with commit..."
        fi
        exit 0
    fi
}

# Run main function
main "$@"